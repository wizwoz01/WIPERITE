import os
import mmap
import numpy as np

SYSFS_FB = '/sys/class/graphics/fb1'
FB_DEVICE = '/dev/fb1'

def fb_info(sysfs=SYSFS_FB):
    w,h = map(int, open(os.path.join(sysfs, 'virtual_size')).read().strip().split(','))
    bpp = int(open(os.path.join(sysfs, 'bits_per_pixel')).read().strip())
    stride = int(open(os.path.join(sysfs, 'stride')).read().strip())
    return w,h,bpp,stride

class ST7789:
    def __init__(self, fb=FB_DEVICE):
        self.fb = fb
        self.width, self.height, self.bpp, self.stride = fb_info()

    # Basic color helper
    @staticmethod
    def color565(r, g, b):
        return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)

    def clear(self):
        # fill black
        self.fill(0)

    # Primitive pixel write (works for 16bpp & 32bpp framebuffers)
    def draw_pixel(self, x, y, color565):
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            return
        fd = os.open(self.fb, os.O_RDWR)
        try:
            if self.bpp == 16:
                hi = (color565 >> 8) & 0xFF
                lo = color565 & 0xFF
                dest = y * self.stride + x * 2
                os.lseek(fd, dest, os.SEEK_SET)
                os.write(fd, bytes([hi, lo]))
            elif self.bpp == 32:
                # assume RGBA ordering; convert color565 to 24-bit RGB
                # expand to 8 bits per channel
                r = ((color565 >> 11) & 0x1F) << 3
                g = ((color565 >> 5) & 0x3F) << 2
                b = (color565 & 0x1F) << 3
                dest = y * self.stride + x * 4
                os.lseek(fd, dest, os.SEEK_SET)
                os.write(fd, bytes([r, g, b, 0xFF]))
        finally:
            os.close(fd)

    def draw_hline(self, x, y, w, color):
        if w <= 0: return
        if y < 0 or y >= self.height: return
        x0 = max(0, x)
        x1 = min(self.width, x + w) - 1
        if x1 < x0: return
        if self.bpp == 16:
            hi = (color >> 8) & 0xFF
            lo = color & 0xFF
            row = bytes([hi, lo]) * (x1 - x0 + 1)
            fd = os.open(self.fb, os.O_RDWR)
            try:
                dest = y * self.stride + x0 * 2
                os.lseek(fd, dest, os.SEEK_SET)
                os.write(fd, row)
            finally:
                os.close(fd)
        else:
            for xi in range(x0, x1+1):
                self.draw_pixel(xi, y, color)

    def draw_vline(self, x, y, h, color):
        if h <= 0: return
        if x < 0 or x >= self.width: return
        y0 = max(0, y)
        y1 = min(self.height, y + h) - 1
        if y1 < y0: return
        for yi in range(y0, y1+1):
            self.draw_pixel(x, yi, color)

    def fill_rect(self, x, y, w, h, color):
        if w <= 0 or h <= 0: return
        x0 = max(0, x)
        y0 = max(0, y)
        x1 = min(self.width, x + w) - 1
        y1 = min(self.height, y + h) - 1
        if x1 < x0 or y1 < y0: return
        if self.bpp == 16:
            hi = (color >> 8) & 0xFF
            lo = color & 0xFF
            row = bytes([hi, lo]) * (x1 - x0 + 1)
            fd = os.open(self.fb, os.O_RDWR)
            try:
                for yi in range(y0, y1+1):
                    dest = yi * self.stride + x0 * 2
                    os.lseek(fd, dest, os.SEEK_SET)
                    os.write(fd, row)
            finally:
                os.close(fd)
        else:
            for yi in range(y0, y1+1):
                for xi in range(x0, x1+1):
                    self.draw_pixel(xi, yi, color)

    def draw_rect(self, x, y, w, h, color):
        self.draw_hline(x, y, w, color)
        self.draw_hline(x, y+h-1, w, color)
        self.draw_vline(x, y, h, color)
        self.draw_vline(x+w-1, y, h, color)

# 5x8 font (from Adafruit / ST7735 C font)
    Font = bytes([
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
    0x18, 0x3C, 0x7E, 0x3C, 0x18,
    0x1C, 0x57, 0x7D, 0x57, 0x1C,
    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
    0x00, 0x18, 0x3C, 0x18, 0x00,
    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
    0x00, 0x18, 0x24, 0x18, 0x00,
    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
    0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26,
    0x40, 0x7F, 0x05, 0x05, 0x07,
    0x40, 0x7F, 0x05, 0x25, 0x3F,
    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
    0x7F, 0x3E, 0x1C, 0x1C, 0x08,
    0x08, 0x1C, 0x1C, 0x3E, 0x7F,
    0x14, 0x22, 0x7F, 0x22, 0x14,
    0x5F, 0x5F, 0x00, 0x5F, 0x5F,
    0x06, 0x09, 0x7F, 0x01, 0x7F,
    0x00, 0x66, 0x89, 0x95, 0x6A,
    0x60, 0x60, 0x60, 0x60, 0x60,
    0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08,
    0x10, 0x20, 0x7E, 0x20, 0x10,
    0x08, 0x08, 0x2A, 0x1C, 0x08,
    0x08, 0x1C, 0x2A, 0x08, 0x08,
    0x1E, 0x10, 0x10, 0x10, 0x10,
    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
    0x30, 0x38, 0x3E, 0x38, 0x30,
    0x06, 0x0E, 0x3E, 0x0E, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x5F, 0x00, 0x00,
    0x00, 0x07, 0x00, 0x07, 0x00,
    0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12,
    0x23, 0x13, 0x08, 0x64, 0x62,
    0x36, 0x49, 0x56, 0x20, 0x50,
    0x00, 0x08, 0x07, 0x03, 0x00,
    0x00, 0x1C, 0x22, 0x41, 0x00,
    0x00, 0x41, 0x22, 0x1C, 0x00,
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
    0x08, 0x08, 0x3E, 0x08, 0x08,
    0x00, 0x80, 0x70, 0x30, 0x00,
    0x08, 0x08, 0x08, 0x08, 0x08,
    0x00, 0x00, 0x60, 0x60, 0x00,
    0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E,
    0x00, 0x42, 0x7F, 0x40, 0x00,
    0x72, 0x49, 0x49, 0x49, 0x46,
    0x21, 0x41, 0x49, 0x4D, 0x33,
    0x18, 0x14, 0x12, 0x7F, 0x10,
    0x27, 0x45, 0x45, 0x45, 0x39,
    0x3C, 0x4A, 0x49, 0x49, 0x31,
    0x41, 0x21, 0x11, 0x09, 0x07,
    0x36, 0x49, 0x49, 0x49, 0x36,
    0x46, 0x49, 0x49, 0x29, 0x1E,
    0x00, 0x00, 0x14, 0x00, 0x00,
    0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41,
    0x14, 0x14, 0x14, 0x14, 0x14,
    0x00, 0x41, 0x22, 0x14, 0x08,
    0x02, 0x01, 0x59, 0x09, 0x06,
    0x3E, 0x41, 0x5D, 0x59, 0x4E,
    0x7C, 0x12, 0x11, 0x12, 0x7C,
    0x7F, 0x49, 0x49, 0x49, 0x36,
    0x3E, 0x41, 0x41, 0x41, 0x22,
    0x7F, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x49, 0x49, 0x49, 0x41,
    0x7F, 0x09, 0x09, 0x09, 0x01,
    0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F,
    0x00, 0x41, 0x7F, 0x41, 0x00,
    0x20, 0x40, 0x41, 0x3F, 0x01,
    0x7F, 0x08, 0x14, 0x22, 0x41,
    0x7F, 0x40, 0x40, 0x40, 0x40,
    0x7F, 0x02, 0x1C, 0x02, 0x7F,
    0x7F, 0x04, 0x08, 0x10, 0x7F,
    0x3E, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x09, 0x09, 0x09, 0x06,
    0x3E, 0x41, 0x51, 0x21, 0x5E,
    0x7F, 0x09, 0x19, 0x29, 0x46,
    0x26, 0x49, 0x49, 0x49, 0x32,
    0x02, 0x04, 0x08, 0x10, 0x20,
    0x00, 0x7F, 0x41, 0x41, 0x41,
    0x04, 0x02, 0x01, 0x02, 0x04,
    0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00,
    0x20, 0x54, 0x54, 0x78, 0x40,
    0x7F, 0x28, 0x44, 0x44, 0x38,
    0x38, 0x44, 0x44, 0x44, 0x28,
    0x38, 0x44, 0x44, 0x28, 0x7F,
    0x38, 0x54, 0x54, 0x54, 0x18,
    0x00, 0x08, 0x7E, 0x09, 0x02,
    0x18, 0xA4, 0xA4, 0x9C, 0x78,
    0x7F, 0x08, 0x04, 0x04, 0x78,
    0x00, 0x44, 0x7D, 0x40, 0x00,
    0x20, 0x40, 0x40, 0x3D, 0x00,
    0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00,
    0x7C, 0x04, 0x78, 0x04, 0x78,
    0x7C, 0x08, 0x04, 0x04, 0x78,
    0x38, 0x44, 0x44, 0x44, 0x38,
    0xFC, 0x18, 0x24, 0x24, 0x18,
    0x18, 0x24, 0x24, 0x18, 0xFC,
    0x7C, 0x08, 0x04, 0x04, 0x08,
    0x48, 0x54, 0x54, 0x54, 0x24,
    0x04, 0x04, 0x3F, 0x44, 0x24,
    0x3C, 0x40, 0x40, 0x20, 0x7C,
    0x1C, 0x20, 0x40, 0x20, 0x1C,
    0x3C, 0x40, 0x38, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44,
    0x4C, 0x90, 0x90, 0x90, 0x7C,
    0x44, 0x64, 0x54, 0x4C, 0x44,
    0x00, 0x08, 0x36, 0x41, 0x00,
    0x00, 0x00, 0x77, 0x00, 0x00,
    0x00, 0x41, 0x36, 0x08, 0x00,
    0x02, 0x01, 0x02, 0x04, 0x02,
    0x3C, 0x26, 0x23, 0x26, 0x3C,
    0x1E, 0xA1, 0xA1, 0x61, 0x12,
    0x3A, 0x40, 0x40, 0x20, 0x7A,
    0x38, 0x54, 0x54, 0x55, 0x59,
    0x21, 0x55, 0x55, 0x79, 0x41,
    0x21, 0x54, 0x54, 0x78, 0x41,
    0x21, 0x55, 0x54, 0x78, 0x40,
    0x20, 0x54, 0x55, 0x79, 0x40,
    0x0C, 0x1E, 0x52, 0x72, 0x12,
    0x39, 0x55, 0x55, 0x55, 0x59,
    0x39, 0x54, 0x54, 0x54, 0x59,
    0x39, 0x55, 0x54, 0x54, 0x58,
    0x00, 0x00, 0x45, 0x7C, 0x41,
    0x00, 0x02, 0x45, 0x7D, 0x42,
    0x00, 0x01, 0x45, 0x7C, 0x40,
    0xF0, 0x29, 0x24, 0x29, 0xF0,
    0xF0, 0x28, 0x25, 0x28, 0xF0,
    0x7C, 0x54, 0x55, 0x45, 0x00,
    0x20, 0x54, 0x54, 0x7C, 0x54,
    0x7C, 0x0A, 0x09, 0x7F, 0x49,
    0x32, 0x49, 0x49, 0x49, 0x32,
    0x32, 0x48, 0x48, 0x48, 0x32,
    0x32, 0x4A, 0x48, 0x48, 0x30,
    0x3A, 0x41, 0x41, 0x21, 0x7A,
    0x3A, 0x42, 0x40, 0x20, 0x78,
    0x00, 0x9D, 0xA0, 0xA0, 0x7D,
    0x39, 0x44, 0x44, 0x44, 0x39,
    0x3D, 0x40, 0x40, 0x40, 0x3D,
    0x3C, 0x24, 0xFF, 0x24, 0x24,
    0x48, 0x7E, 0x49, 0x43, 0x66,
    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
    0xFF, 0x09, 0x29, 0xF6, 0x20,
    0xC0, 0x88, 0x7E, 0x09, 0x03,
    0x20, 0x54, 0x54, 0x79, 0x41,
    0x00, 0x00, 0x44, 0x7D, 0x41,
    0x30, 0x48, 0x48, 0x4A, 0x32,
    0x38, 0x40, 0x40, 0x22, 0x7A,
    0x00, 0x7A, 0x0A, 0x0A, 0x72,
    0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28,
    0x26, 0x29, 0x29, 0x29, 0x26,
    0x30, 0x48, 0x4D, 0x40, 0x20,
    0x38, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x38,
    0x2F, 0x10, 0xC8, 0xAC, 0xBA,
    0x2F, 0x10, 0x28, 0x34, 0xFA,
    0x00, 0x00, 0x7B, 0x00, 0x00,
    0x08, 0x14, 0x2A, 0x14, 0x22,
    0x22, 0x14, 0x2A, 0x14, 0x08,
    0xAA, 0x00, 0x55, 0x00, 0xAA,
    0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0x00, 0x00, 0x00, 0xFF, 0x00,
    0x10, 0x10, 0x10, 0xFF, 0x00,
    0x14, 0x14, 0x14, 0xFF, 0x00,
    0x10, 0x10, 0xFF, 0x00, 0xFF,
    0x10, 0x10, 0xF0, 0x10, 0xF0,
    0x14, 0x14, 0x14, 0xFC, 0x00,
    0x14, 0x14, 0xF7, 0x00, 0xFF,
    0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x14, 0x14, 0xF4, 0x04, 0xFC,
    0x14, 0x14, 0x17, 0x10, 0x1F,
    0x10, 0x10, 0x1F, 0x10, 0x1F,
    0x14, 0x14, 0x14, 0x1F, 0x00,
    0x10, 0x10, 0x10, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x1F, 0x10,
    0x10, 0x10, 0x10, 0x1F, 0x10,
    0x10, 0x10, 0x10, 0xF0, 0x10,
    0x00, 0x00, 0x00, 0xFF, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0xFF, 0x10,
    0x00, 0x00, 0x00, 0xFF, 0x14,
    0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x1F, 0x10, 0x17,
    0x00, 0x00, 0xFC, 0x04, 0xF4,
    0x14, 0x14, 0x17, 0x10, 0x17,
    0x14, 0x14, 0xF4, 0x04, 0xF4,
    0x00, 0x00, 0xFF, 0x00, 0xF7,
    0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0xF7, 0x00, 0xF7,
    0x14, 0x14, 0x14, 0x17, 0x14,
    0x10, 0x10, 0x1F, 0x10, 0x1F,
    0x14, 0x14, 0x14, 0xF4, 0x14,
    0x10, 0x10, 0xF0, 0x10, 0xF0,
    0x00, 0x00, 0x1F, 0x10, 0x1F,
    0x00, 0x00, 0x00, 0x1F, 0x14,
    0x00, 0x00, 0x00, 0xFC, 0x14,
    0x00, 0x00, 0xF0, 0x10, 0xF0,
    0x10, 0x10, 0xFF, 0x10, 0xFF,
    0x14, 0x14, 0x14, 0xFF, 0x14,
    0x10, 0x10, 0x10, 0x1F, 0x00,
    0x00, 0x00, 0x00, 0xF0, 0x10,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xFF,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0x38, 0x44, 0x44, 0x38, 0x44,
    0x7C, 0x2A, 0x2A, 0x3E, 0x14,
    0x7E, 0x02, 0x02, 0x06, 0x06,
    0x02, 0x7E, 0x02, 0x7E, 0x02,
    0x63, 0x55, 0x49, 0x41, 0x63,
    0x38, 0x44, 0x44, 0x3C, 0x04,
    0x40, 0x7E, 0x20, 0x1E, 0x20,
    0x06, 0x02, 0x7E, 0x02, 0x02,
    0x99, 0xA5, 0xE7, 0xA5, 0x99,
    0x1C, 0x2A, 0x49, 0x2A, 0x1C,
    0x4C, 0x72, 0x01, 0x72, 0x4C,
    0x30, 0x4A, 0x4D, 0x4D, 0x30,
    0x30, 0x48, 0x78, 0x48, 0x30,
    0xBC, 0x62, 0x5A, 0x46, 0x3D,
    0x3E, 0x49, 0x49, 0x49, 0x00,
    0x7E, 0x01, 0x01, 0x01, 0x7E,
    0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
    0x44, 0x44, 0x5F, 0x44, 0x44,
    0x40, 0x51, 0x4A, 0x44, 0x40,
    0x40, 0x44, 0x4A, 0x51, 0x40,
    0x00, 0x00, 0xFF, 0x01, 0x03,
    0xE0, 0x80, 0xFF, 0x00, 0x00,
    0x08, 0x08, 0x6B, 0x6B, 0x08,
    0x36, 0x12, 0x36, 0x24, 0x36,
    0x06, 0x0F, 0x09, 0x0F, 0x06,
    0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00,
    0x30, 0x40, 0xFF, 0x01, 0x01,
    0x00, 0x1F, 0x01, 0x01, 0x1E,
    0x00, 0x19, 0x1D, 0x17, 0x12,
    0x00, 0x3C, 0x3C, 0x3C, 0x3C,
    0x00, 0x00, 0x00, 0x00, 0x00,
    ])

    # Draw character using 5x8 font
    def draw_char(self, x, y, c, fg, bg=None, size=1):
        # c: ascii int or 1-char string
        if isinstance(c, str):
            c = ord(c)
        idx = c * 5
        if idx + 5 > len(self.Font):
            return
        for col in range(5):
            line = self.Font[idx + col]
            # In Python2 `bytes` indexing returns a 1-char `str` - convert to int
            if isinstance(line, str):
                line = ord(line)
            for row in range(8):
                pixel_on = (line >> row) & 1
                color = fg if pixel_on else (bg if bg is not None else None)
                if color is None and not pixel_on:
                    continue
                if size == 1:
                    if color is not None:
                        self.draw_pixel(x+col, y+row, color)
                else:
                    if color is not None:
                        self.fill_rect(x+col*size, y+row*size, size, size, color)

    def draw_text(self, x, y, text, fg, bg=None, size=1):
        xx = x
        for ch in text:
            self.draw_char(xx, y, ch, fg, bg, size)
            xx += 6 * size

    def fill(self, color565):
        if self.bpp != 16:
            raise RuntimeError('fill expects 16bpp framebuffer')
        hi = (color565 >> 8) & 0xFF
        lo = color565 & 0xFF
        row = bytes([hi, lo]) * self.width
        fd = os.open(self.fb, os.O_RDWR)
        map_size = self.stride * self.height
        try:
            try:
                mm = mmap.mmap(fd, map_size, flags=mmap.MAP_SHARED, prot=mmap.PROT_WRITE)
                row_len = len(row)
                # Ensure we write exactly `stride` bytes per scanline to the mmap
                if row_len == self.stride:
                    for r in range(self.height):
                        dest = r * self.stride
                        mm[dest:dest+row_len] = row
                else:
                    if row_len < self.stride:
                        pad = b'\x00' * (self.stride - row_len)
                        row_padded = row + pad
                    else:
                        row_padded = row[:self.stride]
                    for r in range(self.height):
                        dest = r * self.stride
                        mm[dest:dest+self.stride] = row_padded
                mm.close()
            except (OSError, ValueError):
                # Fallback using plain write; match the same padding/truncation
                row_len = len(row)
                if row_len == self.stride:
                    for r in range(self.height):
                        dest = r * self.stride
                        os.lseek(fd, dest, os.SEEK_SET)
                        os.write(fd, row)
                else:
                    if row_len < self.stride:
                        pad = b'\x00' * (self.stride - row_len)
                        row_padded = row + pad
                    else:
                        row_padded = row[:self.stride]
                    for r in range(self.height):
                        dest = r * self.stride
                        os.lseek(fd, dest, os.SEEK_SET)
                        os.write(fd, row_padded)
        finally:
            os.close(fd)

    def draw_frame(self, frame):
        """
        Draw an OpenCV BGR `frame` (numpy array) to the framebuffer.
        The function will resize the frame to display resolution and
        convert BGR -> RGB565 (native ordering for the framebuffer).
        """
        import cv2
        # Resize to display resolution
        h,w = frame.shape[:2]
        if (w,h) != (self.width, self.height):
            frame_resized = cv2.resize(frame, (self.width, self.height), interpolation=cv2.INTER_AREA)
        else:
            frame_resized = frame

        if self.bpp == 16:
            # frame_resized is BGR (OpenCV). Convert vectorized to RGB565
            arr = frame_resized.astype(np.uint16)
            b = arr[:,:,0]
            g = arr[:,:,1]
            r = arr[:,:,2]
            rgb565 = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)
            hi = (rgb565 >> 8).astype(np.uint8)
            lo = (rgb565 & 0xFF).astype(np.uint8)
            # interleave hi/lo per pixel row-major
            out = np.empty((self.height, self.width*2), dtype=np.uint8)
            out[:,0::2] = hi
            out[:,1::2] = lo
            buf = out.tobytes()
        elif self.bpp == 32:
            # assume BGRA or RGBA depending on driver; use BGR->RGBA
            import cv2
            rgba = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2RGBA)
            buf = rgba.tobytes()
        else:
            raise RuntimeError('Unsupported bpp: {}'.format(self.bpp))

        fd = os.open(self.fb, os.O_RDWR)
        map_size = self.stride * self.height
        try:
            try:
                mm = mmap.mmap(fd, map_size, flags=mmap.MAP_SHARED, prot=mmap.PROT_WRITE)
                # write row by row honoring stride
                bytes_per_pixel = self.bpp // 8
                row_src = self.width * bytes_per_pixel
                # Ensure per-scanline writes match framebuffer stride
                if row_src == self.stride:
                    for row in range(self.height):
                        start = row * row_src
                        dest = row * self.stride
                        mm[dest:dest+row_src] = buf[start:start+row_src]
                else:
                    if row_src < self.stride:
                        pad = b'\x00' * (self.stride - row_src)
                        for row in range(self.height):
                            start = row * row_src
                            dest = row * self.stride
                            mm[dest:dest+self.stride] = buf[start:start+row_src] + pad
                    else:
                        for row in range(self.height):
                            start = row * row_src
                            dest = row * self.stride
                            mm[dest:dest+self.stride] = buf[start:start+self.stride]
                mm.close()
            except (OSError, ValueError):
                # fallback
                bytes_per_pixel = self.bpp // 8
                row_src = self.width * bytes_per_pixel
                # Fallback using writes; match stride behavior as above
                if row_src == self.stride:
                    for row in range(self.height):
                        start = row * row_src
                        dest = row * self.stride
                        os.lseek(fd, dest, os.SEEK_SET)
                        os.write(fd, buf[start:start+row_src])
                else:
                    if row_src < self.stride:
                        pad = b'\x00' * (self.stride - row_src)
                        for row in range(self.height):
                            start = row * row_src
                            dest = row * self.stride
                            os.lseek(fd, dest, os.SEEK_SET)
                            os.write(fd, buf[start:start+row_src] + pad)
                    else:
                        for row in range(self.height):
                            start = row * row_src
                            dest = row * self.stride
                            os.lseek(fd, dest, os.SEEK_SET)
                            os.write(fd, buf[start:start+self.stride])
        finally:
            os.close(fd)